# Mustache(머스테치)로 화면 구성하기

## 템플릿 엔진
* 템플릿 엔진은 지정된 템플릿 양식과 데이터가 합쳐져 HTML 문서를 출력하는 소프트웨어이다.
* HTML을 최종적으로 생성하는 단계가 서버인지 클라이언트인지에 따라 서버 템플릿 엔진과 클라이언트 템플릿 엔진으로 나뉜다.

### 서버 템플릿 엔진
* JSP, Freemarker, Thymeleaf, Velocity 등 자바 진영에는 다양한 템플릿 엔진이 존재한다.
* 엄연히 말하면 JSP는 템플릿 엔진은 아니지만, 단순 VIEW 템플릿 엔진으로 사용할 수도 있다.
> JSP(Java Server Page)로 HTML,XML,SOAP 등의 문서 유형을 기반으로 동적인 웹 페이지를 생성하기 위한 기술이다.
> JSP는 런타임 시점에 Java Servlet으로 변환 된다. 이 때 JSP의 코드 기반으로 최종적인 HTML 결과물이 생성되어 브라우저(클라이언트)에게 전달된다.

### 클라이언트 템플릿 엔진
* React.js나 Vue.js는 기본적으로 SPA(Single Page Application) 형태로 브라우저에서 화면을 생성 한다.
* 서버 템플릿 엔진 처럼 브라우저가 최종 결과물을 받아 쓰기만 하는 것이 아니므로, 전체 페이지는 한번 로딩하고 동적인 부분만 바뀐다.
* (반면 서버 템플릿 엔진은 전체 페이지가 새로고침된다.)
* 최근엔 프론트엔드 프레임워크들도 SSR(Server Side Rendering)을 지원한다.
> 여담으로 페이스북 공유하기 등을 위해 HTML의 <meta> 태그들을 본문의 내용으로 바꾸려면 SSR로 해야 한다.

## Mustache(머스테치)
* 자바스크립트, 루비, 파이썬, 자바, 펄, Go 등 수많은 언어를 지원하는 심플한 템플릿 엔진
* 자바로 쓸 때는 서버 템플릿 엔진, 자바스크립트를 쓸 때는 클라이언트 템플릿 엔진으로 활용 가능하다.

### 자바 진영 템플릿 엔진 단점
* JSP, Velocity: 스프링 부트에서 권장하지 않음.
* Freemarker: 템플릿 엔진으로는 많은 기능을 과하게 지원하고, 높은 자유도로 인해 숙련도가 낮을 경우 복잡해짐
* Thymeleaf: 스프링에서 권장하는 템플릿 엔진이지만 문법이 어렵다.

### 머스테치의 장점
* 문법이 간단하다.
* 서버 로직 코드를 사용할 수 없으므로 View의 역할과 서버 역할을 명확히 분리 할 수 있다.
* Mustache.js와 Mustache.java 가 있어 하나의 문법으로 클라이언트/서버 모두 사용 가능하다.
* IntelliJ 커뮤니티(무료) 버전에서도 플러그인이 지원된다.

### 의존성 추가
```groovy
dependencies {
    implementation('org.springframework.boot:spring-boot-starter-mustache')
}
```
* 스프링 부트에서 공식 지원하는 템플릿 엔진
* 기본적으로 /src/main/resources/templates 디렉토리에 위치하면 스프링 부트가 자동으로 로딩한다.

## Querydsl
* 규모가 큰 DB구조에서 FK 조인, 복잡한 조건문 등의 쿼리는 JPA Entity 만으로는 표현하기 복잡하다.
* 이를 처리하기 위해 조회용 프레임워크를 같이 사용한다.
* MyBatis, jOOQ, Querydsl 등이 있다.
* 그 중 Querydsl을 자주 사용하는데 이유는 다음과 같다.

### Querydsl 사용 이유
1. 타입 안정성이 보장된다.
  * 메서드를 기반으로 쿼리를 사용하므로 오타나 없는 컬럼명 등이 IDE에서 자동으로 검출 된다.
  * jOOQ도 가지는 장점이지만, MyBatis는 지원하지 않는다.
  * 실제로 MyBatis에서 아주 사소한 오타 등의 잘못된 쿼리로 오류가 발생하고, 이를 찾는데 시간이 걸리는 경우가 있다.

2. 국내 많은 회사에서 사용 한다.
  * 쿠팡, 우아한형제들 등 JPA를 적극적으로 사용하는 회사에선 Querydsl도 같이 적극적으로 사용한다.
  
3. 레퍼런스가 많다.
  * 많이 사용되는 프레임워크인 만큼 자료가 많고, 커뮤니티에 질문을 올리면 답을 얻기 쉽다.


## @Transactional(readOnly = true)
* 트랜잭션 범위는 유지하되 조회 기능만 남겨두어 조회 속도가 개선되므로 등록, 수정, 삭제 기능이 없는 서비스 메소드에서 사용
* JPA 구현체에 Hint를 제공하여 속도를 개선할 수 있고, 큰 객체 트리의 경우 눈에 띄게 증가한다고 한다.
* 몇몇 Database는 INSERT, UPDATE 문을 거부 할 수 있다.
* [참고 문서](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#transactions)

